
package elements;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.Arrays;

import org.junit.Before;
import org.junit.Test;

import parser.ColumnIndexOutOfBoundsException;

/**
 * Test cases for Table.java
 *
 * @version 2
 *
 * @author Prajjwal Bhandari
 * @author Hardarshan Kahlon
 * @author Ansar Butt
 * @author Alvaro Naranjo
 *
 */
public class TableTest {
	/**
	 * Table to use in tests.
	 */
	private Table table;
	/**
	 * List of Rows to use in tests.
	 */
	private ArrayList<Row> rowList;
	/**
	 * Cell lists to construct Rows.
	 */
	private ArrayList<Cell> cellList1, cellList2;
	/**
	 * Header to use in tests.
	 */
	private ArrayList<String> tableheader;
	/**
	 * Rows to construct tables.
	 */
	private Row row1, row2;

	/**
	 * @throws java.lang.Exception Autogenerated
	 */
	@Before
	public final void setUp() throws Exception {
		tableheader = new ArrayList<String>(Arrays.asList("H1", "H2"));
		table = new Table(Arrays.asList(false, true), tableheader);

		rowList = new ArrayList<Row>();

		cellList1 = new ArrayList<Cell>(Arrays.asList(
				new StringCell("po"), new NumberCell(56)));
		cellList2 = new ArrayList<Cell>(Arrays.asList(
				new StringCell("A"), new NumberCell(2)));

		row1 = new Row(cellList1);
		row2 = new Row(cellList2);

		table.add(row1);
		table.add(row2);


	}

	/**
	 * Test method for Table#add(parser.Row).
	 */
	@Test
	public final void testAdd() {
		// check properly adding a row following table's definition
		assertTrue(table.add(row1));

		// check table's table was properly updated
		assertEquals(row1, table.getRow(2));

		// check size is properly updated
		assertEquals(3, table.size());

		// check not adding a with mismatch in columns
		Row rowDiffCols = new Row(new ArrayList<Cell>(
				Arrays.asList(new StringCell("Y"))));
		assertFalse(table.add(rowDiffCols));

		// check not adding a row with mismatch in types
		Row rowDiffTypes = new Row(new ArrayList<Cell>(
				Arrays.asList(new StringCell("Y"), new StringCell("X"))));
		assertFalse(table.add(rowDiffTypes));
	}

	/**
	 * Test method for Table#addAll(java.util.List).
	 */
	@Test
	public void testAddAll() {
		Table testTable = new Table(table.getDefinition());

		rowList.add(row1);
		rowList.add(row2);

		assertTrue(testTable.addAll(rowList));
		assertEquals(rowList, table.getAllRows());

		// checking to make sure that the addition is not destructive
		rowList.add(new Row());
		assertNotSame(rowList, table.getAllRows());
	}

	/**
	 * Test method for Table#addAll(java.util.List).
	 */
	@Test
	public final void testAddAllFailRowColumnMismatch() {
		Table testTable = new Table(table.getDefinition());

		//Insert a row with mismatching columns to rowList
		Row badColsRow = new Row(new ArrayList<Cell>(Arrays.asList(
				 new StringCell("."))));
		rowList.add(badColsRow);

		//check not adding rowList containing a row with mismatching columns
		assertFalse(testTable.addAll(rowList));
	}

	/**
	 * Test method for Table#addAll(java.util.List).
	 */
	@Test
	public final void testAddAllFailRowTypeMismatch() {
		Table testTable = new Table(table.getDefinition());

		//Insert a row with mismatching types to rowList
		Row badTypesRow = new Row(new ArrayList<Cell>(Arrays.asList(
				 new StringCell("."), new StringCell("u"))));
		rowList.add(badTypesRow);

		//check not adding rowList containing a row with mismatching types
		assertFalse(testTable.addAll(rowList));
	}

	/**
	 * Test method for Table#sort(int).
	 *
	 * @throws ColumnIndexOutOfBoundsException inherited from Table.sort
	 */
	@Test
	public final void testSort() throws ColumnIndexOutOfBoundsException {
		Table sortedTable1 =
				new Table(table.getDefinition(), table.getHeader());
		Table sortedTable2 =
				new Table(table.getDefinition(), table.getHeader());

		sortedTable1.add(row2);
		sortedTable1.add(row1);

		sortedTable2.add(row2);
		sortedTable2.add(row1);

		//check proper sorting by a column of NumberCells
		assertEquals(sortedTable1, table.sort(1));

		//check proper sorting by a column of StringCells
		assertEquals(sortedTable2, table.sort(0));

		// not doing a test for ColumnIndexOutOfBoundsException since call
		// it should never get thrown here.
	}

	/**
	 * Test method for Table#equals(Object).
	 */
	@Test
	public final void testEquals() {
		// Construct table t0:
		Table t0 = new Table(Arrays.asList(false), tableheader);
		t0.add(new Row(new ArrayList<Cell>(Arrays.asList(
				new StringCell("i")))));
		t0.add(new Row(new ArrayList<Cell>(Arrays.asList(
				new StringCell("j")))));

		// Construct table t1:
		Table t1 = new Table(Arrays.asList(false, true), tableheader);
		t1.add(row1);
		t1.add(row2);

		// Construct table t2:
		Table t2 = new Table(Arrays.asList(false, true));
		t2.add(row1);
		t2.add(row2);
		t2.add(row2);

		// Construct table t3:
		Table t3 = new Table(Arrays.asList(false, true));
		t3.add(row1);
		t3.add(row2);
		t3.add(new Row(Arrays.asList(
				new StringCell("0"), new NumberCell(2))));

		//Construct table t4
		Table t4 = new Table(Arrays.asList(false, true));

		//check returns false for tables with different number of columns
		assertFalse(t0.equals(t1));

		//Trivial Case: both tables are equal.
		assertTrue(table.equals(t1));

		//t1 has more rows.
		t1.add(row1);
		assertFalse(table.equals(t1));

		//check returns false for tables of different contents
		assertFalse(t2.equals(t3));

		//t4 is empty, t3 isn't
		assertFalse(t4.equals(t3));

		//check two emmpty tables with same definition
		assertTrue(t4.equals(new Table(Arrays.asList(false, true))));

		//.equals() for a non-table object
		assertFalse(table.equals(new String("a")));
	}

	/**
	 * Test method for Table#getAllRows().
	 */
	@Test
	public final void testGetAllRows() {
		//check properly returning all Rows in Table's table
		rowList.add(row1);
		rowList.add(row2);
		assertEquals(rowList, table.getAllRows());

		//check that a reference to rowList is not passed to a Table's table
		rowList.add(row1);
		assertFalse(rowList.equals(table.getAllRows()));
	}

	/**
	 * Test method for Table#getRow(int).
	 */
	@Test
	public final void testGetRow() {
		//check properly returning row at valid index
		assertEquals(row1, table.getRow(0));
	}

	/**
	 * Test method for Table#getRow(int).
	 */
	@Test
	public final void testGetRowInvalidIndex() {
		//check returning null when getting a Row at invalid index
		assertEquals(null, table.getRow(775));
	}

	/**
	 * Test method for Table#getColSize().
	 */
	@Test
	public final void testGetColSize() {
		//check returning correct number of columns in Table
		assertEquals(row1.size(), table.getColSize());
	}

	/**
	 * Test method for Table#size().
	 */
	@Test
	public final void testSize() {
		//check getting correct number of rows in headed Table
		//note header is not a Row.
		assertEquals(2, table.size());
	}

	/**
	 * Test method for Table#getCell(int, int).
	 *
	 * @throws ColumnIndexOutOfBoundsException if column is out of bounds
	 */
	@Test
	public final void testGetCell()
			throws ColumnIndexOutOfBoundsException {
		assertEquals(row1.getCell(1), table.getCell(0, 1));
	}

	/**
	 * Test method for Table#getCell(int, int).
	 * case: column index is out of bounds.
	 * @throws ColumnIndexOutOfBoundsException if column index out of bounds
	 */
	@Test(expected = ColumnIndexOutOfBoundsException.class)
	public final void testGetCellInvalidColumnIndex()
			throws ColumnIndexOutOfBoundsException {
		table.getCell(0, 100);
	}

	/**
	 * Test method for Table#getCell(int, int).
	 * case: row index is out of bounds.
	 * @throws ColumnIndexOutOfBoundsException if Column index is out of bounds
	 * @throws IndexOutOfBoundsException if row index out of bounds
	 */
	@Test(expected = IndexOutOfBoundsException.class)
	public final void testGetCellInvalidRowIndex()
			throws ColumnIndexOutOfBoundsException {
		table.getCell(100, 0);
	}

	/**
	 * Test method for Table#hasHead().
	 */
	@Test
	public final void testHasHead() {
		//false for a non headed table
		assertFalse(new Table(Arrays.asList(true)).hasHead());

		//true for headed table
		assertTrue(table.hasHead());
	}

	/**
	 * Test method for Table#getHeader().
	 */
	@Test
	public final void getHeader() {
		//gives empty List for a table without header
		Table nonHeaded = new Table(Arrays.asList(true));

		assertEquals(Arrays.asList(), nonHeaded.getHeader());

		//gives header for headed table
		assertEquals(tableheader, table.getHeader());

		//gives header at a valid index
		try {
			assertEquals(tableheader.get(0), table.getHeader(0));
		} catch (ColumnIndexOutOfBoundsException e) {
			fail("testign valid index");
		}
	}

	/**
	 * Test method for Table#getHeaderOutOfBounds().
	 * test getting a header at an index out of bounds throws exception
	 * @throws ColumnIndexOutOfBoundsException if column index is out of bounds
	 */
	@Test(expected = ColumnIndexOutOfBoundsException.class)
	public final void getHeaderOutOfBounds()
			throws ColumnIndexOutOfBoundsException {
		table.getHeader(8654);
	}

	/**
	 * Test method for Table#setHeader().
	 */
	@Test
	public final void setHeader() {
		//set whole header for non-headed table
		Table nonHeaded = new Table(Arrays.asList(false));
		nonHeaded.setHeader(tableheader);

		assertEquals(tableheader, nonHeaded.getHeader());
		assertTrue(nonHeaded.hasHead());

		//set whole new header for headed table
		ArrayList<String> newHeader =
				new ArrayList<String>(Arrays.asList("col", "ombia"));
		table.setHeader(newHeader);

		assertEquals(newHeader, table.getHeader());
		assertTrue(table.hasHead());
	}

	/**
	 * Test method for Table#removeHeader().
	 */
	@Test
	public final void removeHeader() {
		table.removeHeader();
		//check table has empty header
		assertEquals(Arrays.asList(), table.getHeader());
		assertFalse(table.hasHead());
	}

	/**
	 * Test method for Table#toString().
	 * Test string of headed Table.
	 */
	@Test
	public final void testToStringHeaded() {
		//get header as a String and remove extraneous Spaces
		String headerString =
				table.getHeader().toString().replaceAll(", ", ",");
		//remove the [] placed by default List#toString() method
		headerString = headerString.substring(1, headerString.length() - 1);

		//expectedResult
		String expectd =  headerString + "\n" + row1.toString() + "\n"
					+ row2.toString() + "\n";

		assertEquals(expectd, table.toString());
	}

	/**
	 * Test method for Table#toString().
	 * Test string of non-headed Table.
	 */
	@Test
	public final void testToStringNotHeaded() {
		//remove table's header
		table.removeHeader();
		//expectedResult
		String expectd = row1.toString() + "\n" + row2.toString() + "\n";

		assertEquals(expectd, table.toString());
	}

	/**
	 * Test method for {@link Table#getColumnNumber(String)}.
	 * case: column exists
	 * @throws ColumnIndexOutOfBoundsException if column index is out of bounds
	 */
	@Test
	public final void testGetColumnNumber()
			throws ColumnIndexOutOfBoundsException {
		int testNumber = 0;
		assertEquals(testNumber,
				table.getColumnNumber(tableheader.get(testNumber)));
	}

	/**
	 * Test method for {@link Table#getColumnNumber(String)}.
	 * case: column name given is invalid
	 * @throws ColumnIndexOutOfBoundsException if column index is out of bounds
	 */
	@Test (expected = ColumnIndexOutOfBoundsException.class)
	public final void testGetColumnNumberInvalidColumnName()
			throws ColumnIndexOutOfBoundsException {
		table.getColumnNumber("asdkjfh vasdkgfadgksddddddfagfbascvbnaaaa");
	}

	/**
	 * Test for Table#getDefinition().
	 */
	public final void testGetDefinition() {
		//check correctly returns definition for a table.
		assertEquals(Arrays.asList(false, true), table.getDefinition());
	}

	/**
	 * Test method for Table#Clone().
	 */
	@Test
	public final void testClone() {
		Table t = table.clone();

		//check that cloning works properly
		assertEquals(t, table);

		//check cloning on a table without a header
		Table t1 = table.clone();
		t1.removeHeader();
		assertEquals(t1.clone(), t1);

		//check that the two items aren't the same
		assertFalse(table == t);

		//check that changing a clone doesn't change the original
		t.add(new Row(Arrays.asList(
				new StringCell("pi"), new NumberCell(5))));
		assertFalse(table.equals(t));

		//check that changing the origin doesn't change a clone
		Table t2 = table.clone();
		table.add(new Row(Arrays.asList(
				new StringCell("i"), new NumberCell(4))));
		assertFalse(table.equals(t2));

	}
}
